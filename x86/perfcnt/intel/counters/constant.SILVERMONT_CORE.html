<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `SILVERMONT_CORE` constant in crate `x86`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, SILVERMONT_CORE">

    <title>x86::perfcnt::intel::counters::SILVERMONT_CORE - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../../../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../../../index.html'>x86</a>::<wbr><a href='../../index.html'>perfcnt</a>::<wbr><a href='../index.html'>intel</a>::<wbr><a href='index.html'>counters</a></p><script>window.sidebarCurrent = {name: 'SILVERMONT_CORE', ty: 'constant', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content constant">
<h1 class='fqn'><span class='in-band'><a href='../../../index.html'>x86</a>::<wbr><a href='../../index.html'>perfcnt</a>::<wbr><a href='../index.html'>intel</a>::<wbr><a href='index.html'>counters</a>::<wbr><a class='constant' href=''>SILVERMONT_CORE</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-2714' class='srclink' href='../../../../src/x86///home/gz/workspace/rust-perfcnt/target/debug/build/x86-0c610ed98ea8ba6b/out/counters.rs.html#9165-9324' title='goto source code'>[src]</a></span></h1>
<pre class='rust const'>pub const SILVERMONT_CORE: <a class='struct' href='../../../../phf/map/struct.Map.html' title='phf::map::Map'>Map</a>&lt;&amp;'static str, <a class='struct' href='../../../../x86/perfcnt/intel/description/struct.IntelPerformanceCounterDescription.html' title='x86::perfcnt::intel::description::IntelPerformanceCounterDescription'>IntelPerformanceCounterDescription</a>&gt;<code> = </code><code>::phf::Map {
    key: 1897749892740154578,
    disps: &[
        (0, 6),
        (0, 25),
        (0, 3),
        (0, 59),
        (0, 114),
        (2, 38),
        (4, 0),
        (0, 104),
        (0, 5),
        (0, 0),
        (6, 79),
        (4, 4),
        (0, 119),
        (0, 64),
        (0, 13),
        (1, 36),
        (0, 6),
        (0, 122),
        (2, 89),
        (7, 45),
        (0, 2),
        (73, 73),
        (2, 89),
        (0, 10),
        (0, 4),
        (2, 124),
    ],
    entries: &[
        ("OFFCORE_RESPONSE.PF_L1_DATA_RD.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L1_DATA_RD.L2_MISS.ANY", brief_description: "Counts DCU hardware prefetcher data read  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636772352, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("MEM_UOPS_RETIRED.L2_MISS_LOADS", IntelPerformanceCounterDescription { event_code: Tuple::One(4), umask: Tuple::One(4), event_name: "MEM_UOPS_RETIRED.L2_MISS_LOADS", brief_description: "Loads missed L2", public_description: Some("This event counts the number of load ops retired that miss in the L2"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("MEM_UOPS_RETIRED.L1_MISS_LOADS", IntelPerformanceCounterDescription { event_code: Tuple::One(4), umask: Tuple::One(1), event_name: "MEM_UOPS_RETIRED.L1_MISS_LOADS", brief_description: "Loads missed L1", public_description: Some("This event counts the number of load ops retired that miss in L1 Data cache. Note that prefetch misses will not be counted."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_REQUEST.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_REQUEST.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts any request that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719509512, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.ALL_BRANCHES", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(0), event_name: "BR_INST_RETIRED.ALL_BRANCHES", brief_description: "Counts the number of branch instructions retired...", public_description: Some("ALL_BRANCHES counts the number of any branch instructions retired.  Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.FAR_BRANCH", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(191), event_name: "BR_INST_RETIRED.FAR_BRANCH", brief_description: "Counts the number of far branch instructions retired", public_description: Some("FAR counts the number of far branch instructions retired.  Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_DATA_RD.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_DATA_RD.L2_MISS.SNOOP_MISS", brief_description: "Counts demand and DCU prefetch data read  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589934593, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_CODE_RD.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_CODE_RD.L2_MISS.SNOOP_MISS", brief_description: "Counts demand and DCU prefetch instruction cacheline  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589934596, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_DATA_RD.OUTSTANDING", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_DATA_RD.OUTSTANDING", brief_description: "Counts demand and DCU prefetch data read cycles of outstanding offcore requests", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::One(166), msr_value: 274877906945, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L1_DATA_RD.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L1_DATA_RD.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts DCU hardware prefetcher data read  that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719484928, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.TAKEN_JCC", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(254), event_name: "BR_INST_RETIRED.TAKEN_JCC", brief_description: "Counts the number of taken JCC branch instructions retired", public_description: Some("TAKEN_JCC counts the number of taken conditional branch (JCC) instructions retired. Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.NON_RETURN_IND", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(235), event_name: "BR_INST_RETIRED.NON_RETURN_IND", brief_description: "Counts the number of near indirect JMP and near indirect CALL branch instructions retired", public_description: Some("NON_RETURN_IND counts the number of near indirect JMP and near indirect CALL branch instructions retired.  Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("LONGEST_LAT_CACHE.MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(46), umask: Tuple::One(65), event_name: "LONGEST_LAT_CACHE.MISS", brief_description: "L2 cache request misses", public_description: Some("This event counts the total number of L2 cache references and the number of L2 cache misses respectively."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BACLEARS.COND", IntelPerformanceCounterDescription { event_code: Tuple::One(230), umask: Tuple::One(16), event_name: "BACLEARS.COND", brief_description: "Counts the number of JCC baclears", public_description: Some("The BACLEARS event counts the number of times the front end is resteered, mainly when the Branch Prediction Unit cannot provide a correct prediction and this is corrected by the Branch Address Calculator at the front end.  The BACLEARS.COND event counts the number of JCC (Jump on Condtional Code) baclears."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("REHABQ.ANY_LD", IntelPerformanceCounterDescription { event_code: Tuple::One(3), umask: Tuple::One(64), event_name: "REHABQ.ANY_LD", brief_description: "Any reissued load uops", public_description: Some("This event counts the number of load uops reissued from Rehabq"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("NO_ALLOC_CYCLES.RAT_STALL", IntelPerformanceCounterDescription { event_code: Tuple::One(202), umask: Tuple::One(32), event_name: "NO_ALLOC_CYCLES.RAT_STALL", brief_description: "Counts the number of cycles when no uops are allocated and a RATstall is asserted.", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("REHABQ.ANY_ST", IntelPerformanceCounterDescription { event_code: Tuple::One(3), umask: Tuple::One(128), event_name: "REHABQ.ANY_ST", brief_description: "Any reissued store uops", public_description: Some("This event counts the number of store uops reissued from Rehabq"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_CODE_RD.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_CODE_RD.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts any code reads (demand & prefetch)  that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719476804, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("PAGE_WALKS.D_SIDE_CYCLES", IntelPerformanceCounterDescription { event_code: Tuple::One(5), umask: Tuple::One(1), event_name: "PAGE_WALKS.D_SIDE_CYCLES", brief_description: "Duration of D-side page-walks in core cycles", public_description: Some("This event counts every cycle when a D-side (walks due to a load) page walk is in progress. Page walk duration divided by number of page walks is the average duration of page-walks."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.COREWB.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.COREWB.L2_MISS.ANY", brief_description: "Counts writeback (modified to exclusive)  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764168, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_RFO.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_RFO.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts RFO requests generated by L2 prefetchers  that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719476768, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_RFO.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_RFO.L2_MISS.SNOOP_MISS", brief_description: "Counts demand and DCU prefetch RFOs  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589934594, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_REQUEST.ANY_RESPONSE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_REQUEST.ANY_RESPONSE", brief_description: "Counts any request that have any response type", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 98312, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_RFO.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_RFO.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts any rfo reads (demand & prefetch)  that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719476770, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("DECODE_RESTRICTION.PREDECODE_WRONG", IntelPerformanceCounterDescription { event_code: Tuple::One(233), umask: Tuple::One(1), event_name: "DECODE_RESTRICTION.PREDECODE_WRONG", brief_description: "Counts the number of times a decode restriction reduced the decode throughput due to wrong instruction length prediction", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("PAGE_WALKS.D_SIDE_WALKS", IntelPerformanceCounterDescription { event_code: Tuple::One(5), umask: Tuple::One(1), event_name: "PAGE_WALKS.D_SIDE_WALKS", brief_description: "D-side page-walks", public_description: Some("This event counts when a data (D) page walk is completed or started.  Since a page walk implies a TLB miss, the number of TLB misses can be counted by counting the number of pagewalks."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: true, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("REHABQ.LD_SPLITS", IntelPerformanceCounterDescription { event_code: Tuple::One(3), umask: Tuple::One(8), event_name: "REHABQ.LD_SPLITS", brief_description: "Load uops that split cache line boundary", public_description: Some("This event counts the number of retire loads that experienced cache line boundary splits"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_DATA_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_DATA_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts any data read (demand & prefetch)  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179881617, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_DATA_RD.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_DATA_RD.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts any data read (demand & prefetch)  that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719489169, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("MEM_UOPS_RETIRED.UTLB_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(4), umask: Tuple::One(16), event_name: "MEM_UOPS_RETIRED.UTLB_MISS", brief_description: "Loads missed UTLB", public_description: Some("This event counts the number of load ops retired that had UTLB miss."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_DATA_RD.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_DATA_RD.L2_MISS.ANY", brief_description: "Counts data cacheline reads generated by L2 prefetchers  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764176, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_RFO.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_RFO.L2_MISS.SNOOP_MISS", brief_description: "Counts any rfo reads (demand & prefetch)  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589934626, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("NO_ALLOC_CYCLES.ALL", IntelPerformanceCounterDescription { event_code: Tuple::One(202), umask: Tuple::One(63), event_name: "NO_ALLOC_CYCLES.ALL", brief_description: "Counts the number of cycles when no uops are allocated for any reason.", public_description: Some("The NO_ALLOC_CYCLES.ALL event counts the number of cycles when the front-end does not provide any instructions to be allocated for any reason. This event indicates the cycles where an allocation stalls occurs, and no UOPS are allocated in that cycle."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L1_DATA_RD.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L1_DATA_RD.L2_MISS.SNOOP_MISS", brief_description: "Counts DCU hardware prefetcher data read  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589942784, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("CORE_REJECT_L2Q.ALL", IntelPerformanceCounterDescription { event_code: Tuple::One(49), umask: Tuple::One(0), event_name: "CORE_REJECT_L2Q.ALL", brief_description: "Counts the number of request that were not accepted into the L2Q because the L2Q is FULL.", public_description: Some("Counts the number of (demand and L1 prefetchers) core requests rejected by the L2Q due to a full or nearly full w condition which likely indicates back pressure from L2Q.  It also counts requests that would have gone directly to the XQ, but are rejected due to a full or nearly full condition, indicating back pressure from the IDI link.  The L2Q may also reject transactions  from a core to insure fairness between cores, or to delay a core?s dirty eviction when the address conflicts incoming external snoops.  (Note that L2 prefetcher requests that are dropped are not counted by this event.)"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("MEM_UOPS_RETIRED.HITM", IntelPerformanceCounterDescription { event_code: Tuple::One(4), umask: Tuple::One(32), event_name: "MEM_UOPS_RETIRED.HITM", brief_description: "Cross core or cross module hitm", public_description: Some("This event counts the number of load ops retired that got data from the other core or from the other module."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_MISP_RETIRED.IND_CALL", IntelPerformanceCounterDescription { event_code: Tuple::One(197), umask: Tuple::One(251), event_name: "BR_MISP_RETIRED.IND_CALL", brief_description: "Counts the number of mispredicted near indirect CALL branch instructions retired", public_description: Some("IND_CALL counts the number of mispredicted near indirect CALL branch instructions retired.  This event counts the number of retired branch instructions that were mispredicted by the processor, categorized by type. A branch misprediction occurs when the processor predicts that the branch would be taken, but it is not, or vice-versa.  When the misprediction is discovered, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_CODE_RD.OUTSTANDING", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_CODE_RD.OUTSTANDING", brief_description: "Counts demand and DCU prefetch instruction cacheline cycles of outstanding offcore requests", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::One(166), msr_value: 274877906948, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("MACHINE_CLEARS.ALL", IntelPerformanceCounterDescription { event_code: Tuple::One(195), umask: Tuple::One(8), event_name: "MACHINE_CLEARS.ALL", brief_description: "Counts all machine clears", public_description: Some("Machine clears happen when something happens in the machine that causes the hardware to need to take special care to get the right answer. When such a condition is signaled on an instruction, the front end of the machine is notified that it must restart, so no more instructions will be decoded from the current path.  All instructions \"older\" than this one will be allowed to finish.  This instruction and all \"younger\" instructions must be cleared, since they must not be allowed to complete.  Essentially, the hardware waits until the problematic instruction is the oldest instruction in the machine.  This means all older instructions are retired, and all pending stores (from older instructions) are completed.  Then the new path of instructions from the front end are allowed to start into the machine.  There are many conditions that might cause a machine clear (including the receipt of an interrupt, or a trap or a fault).  All those conditions (including but not limited to MACHINE_CLEARS.MEMORY_ORDERING, MACHINE_CLEARS.SMC, and MACHINE_CLEARS.FP_ASSIST) are captured in the ANY event. In addition, some conditions can be specifically counted (i.e. SMC, MEMORY_ORDERING, FP_ASSIST).  However, the sum of SMC, MEMORY_ORDERING, and FP_ASSIST machine clears will not necessarily equal the number of ANY."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_RFO.OUTSTANDING", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_RFO.OUTSTANDING", brief_description: "Counts demand and DCU prefetch RFOs cycles of outstanding offcore requests", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::One(166), msr_value: 274877906946, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("FETCH_STALL.ICACHE_FILL_PENDING_CYCLES", IntelPerformanceCounterDescription { event_code: Tuple::One(134), umask: Tuple::One(4), event_name: "FETCH_STALL.ICACHE_FILL_PENDING_CYCLES", brief_description: "Counts the number of cycles the NIP stalls because of an icache miss. This is a cumulative count of cycles the NIP stalled for all icache misses.", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_DATA_RD.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_DATA_RD.L2_MISS.SNOOP_MISS", brief_description: "Counts any data read (demand & prefetch)  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589947025, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_RFO.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_RFO.L2_MISS.ANY", brief_description: "Counts any rfo reads (demand & prefetch)  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764194, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("UOPS_RETIRED.MS", IntelPerformanceCounterDescription { event_code: Tuple::One(194), umask: Tuple::One(1), event_name: "UOPS_RETIRED.MS", brief_description: "MSROM micro-ops retired", public_description: Some("This event counts the number of micro-ops retired that were supplied from MSROM."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("MS_DECODED.MS_ENTRY", IntelPerformanceCounterDescription { event_code: Tuple::One(231), umask: Tuple::One(1), event_name: "MS_DECODED.MS_ENTRY", brief_description: "Counts the number of times entered into a ucode flow in the FEC.  Includes inserted flows due to front-end detected faults or assists.  Speculative count.", public_description: Some("Counts the number of times the MSROM starts a flow of UOPS. It does not count every time a UOP is read from the microcode ROM.  The most common case that this counts is when a micro-coded instruction is encountered by the front end of the machine.  Other cases include when an instruction encounters a fault, trap, or microcode assist of any sort.  The event will count MSROM startups for UOPS that are speculative, and subsequently cleared by branch mispredict or machine clear.  Background: UOPS are produced by two mechanisms.  Either they are generated by hardware that decodes instructions into UOPS, or they are delivered by a ROM (called the MSROM) that holds UOPS associated with a specific instruction.  MSROM UOPS might also be delivered in response to some condition such as a fault or other exceptional condition.  This event is an excellent mechanism for detecting instructions that require the use of MSROM instructions."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_REQUEST.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_REQUEST.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts any request that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179901960, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("CPU_CLK_UNHALTED.REF_TSC", IntelPerformanceCounterDescription { event_code: Tuple::One(0), umask: Tuple::One(3), event_name: "CPU_CLK_UNHALTED.REF_TSC", brief_description: "Fixed Counter: Counts the number of unhalted reference clock cycles", public_description: Some("Counts the number of reference cycles while the core is not in a halt state. The core enters the halt state when it is running the HLT instruction. This event is a component in many key event ratios.  The core frequency may change from time. This event is not affected by core frequency changes but counts as if the core is running at the maximum frequency all the time.  Divide this event count by core frequency to determine the elapsed time while the core was not in halt state.  Divide this event count by core frequency to determine the elapsed time while the core was not in halt state.  This event is architecturally defined and is a designated fixed counter.  CPU_CLK_UNHALTED.CORE and CPU_CLK_UNHALTED.CORE_P use the core frequency which may change from time to time.  CPU_CLK_UNHALTE.REF_TSC and CPU_CLK_UNHALTED.REF are not affected by core frequency changes but counts as if the core is running at the maximum frequency all the time.  The fixed events are CPU_CLK_UNHALTED.CORE and CPU_CLK_UNHALTED.REF_TSC and the programmable events are CPU_CLK_UNHALTED.CORE_P and CPU_CLK_UNHALTED.REF."), counter: Counter::Fixed(8), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("NO_ALLOC_CYCLES.ROB_FULL", IntelPerformanceCounterDescription { event_code: Tuple::One(202), umask: Tuple::One(1), event_name: "NO_ALLOC_CYCLES.ROB_FULL", brief_description: "Counts the number of cycles when no uops are allocated and the ROB is full (less than 2 entries available)", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_DATA_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_DATA_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts demand and DCU prefetch data read  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179869185, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_REQUEST.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_REQUEST.L2_MISS.SNOOP_MISS", brief_description: "Counts any request that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589967368, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_DATA_RD.ANY_RESPONSE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_DATA_RD.ANY_RESPONSE", brief_description: "Counts demand and DCU prefetch data read  that have any response type", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 65537, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("REHABQ.LD_BLOCK_ST_FORWARD", IntelPerformanceCounterDescription { event_code: Tuple::One(3), umask: Tuple::One(1), event_name: "REHABQ.LD_BLOCK_ST_FORWARD", brief_description: "Loads blocked due to store forward restriction", public_description: Some("This event counts the number of retired loads that were prohibited from receiving forwarded data from the store because of address mismatch."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PARTIAL_READS.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PARTIAL_READS.L2_MISS.ANY", brief_description: "Counts demand reads of partial cache lines (including UC and WC)  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764288, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PARTIAL_WRITES.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PARTIAL_WRITES.L2_MISS.ANY", brief_description: "Countsof demand RFO requests to write to partial cache lines  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764416, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("MEM_UOPS_RETIRED.DTLB_MISS_LOADS", IntelPerformanceCounterDescription { event_code: Tuple::One(4), umask: Tuple::One(8), event_name: "MEM_UOPS_RETIRED.DTLB_MISS_LOADS", brief_description: "Loads missed DTLB", public_description: Some("This event counts the number of load ops retired that had DTLB miss."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("INST_RETIRED.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(0), umask: Tuple::One(1), event_name: "INST_RETIRED.ANY", brief_description: "Fixed Counter: Counts the number of instructions retired", public_description: Some("This event counts the number of instructions that retire.  For instructions that consist of multiple micro-ops, this event counts exactly once, as the last micro-op of the instruction retires.  The event continues counting while instructions retire, including during interrupt service routines caused by hardware interrupts, faults or traps.  Background: Modern microprocessors employ extensive pipelining and speculative techniques.  Since sometimes an instruction is started but never completed, the notion of \"retirement\" is introduced.  A retired instruction is one that commits its states. Or stated differently, an instruction might be abandoned at some point. No instruction is truly finished until it retires.  This counter measures the number of completed instructions.  The fixed event is INST_RETIRED.ANY and the programmable event is INST_RETIRED.ANY_P."), counter: Counter::Fixed(2), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("RS_FULL_STALL.ALL", IntelPerformanceCounterDescription { event_code: Tuple::One(203), umask: Tuple::One(31), event_name: "RS_FULL_STALL.ALL", brief_description: "Counts the number of cycles the Alloc pipeline is stalled when any one of the RSs (IEC, FPC and MEC) is full. This event is a superset of all the individual RS stall event counts.", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("ICACHE.MISSES", IntelPerformanceCounterDescription { event_code: Tuple::One(128), umask: Tuple::One(2), event_name: "ICACHE.MISSES", brief_description: "Icache miss", public_description: Some("This event counts all instruction fetches that miss the Instruction cache or produce memory requests. This includes uncacheable fetches. An instruction fetch miss is counted only once and not once for every cycle it is outstanding."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("PAGE_WALKS.CYCLES", IntelPerformanceCounterDescription { event_code: Tuple::One(5), umask: Tuple::One(3), event_name: "PAGE_WALKS.CYCLES", brief_description: "Total cycles for all the page walks. (I-side and D-side)", public_description: Some("This event counts every cycle when a data (D) page walk or instruction (I) page walk is in progress.  Since a pagewalk implies a TLB miss, the approximate cost of a TLB miss can be determined from this event."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE", brief_description: "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("CYCLES_DIV_BUSY.ALL", IntelPerformanceCounterDescription { event_code: Tuple::One(205), umask: Tuple::One(1), event_name: "CYCLES_DIV_BUSY.ALL", brief_description: "Cycles the divider is busy.  Does not imply a stall waiting for the divider.", public_description: Some("Cycles the divider is busy.This event counts the cycles when the divide unit is unable to accept a new divide UOP because it is busy processing a previously dispatched UOP. The cycles will be counted irrespective of whether or not another divide UOP is waiting to enter the divide unit (from the RS). This event might count cycles while a divide is in progress even if the RS is empty.  The divide instruction is one of the longest latency instructions in the machine.  Hence, it has a special event associated with it to help determine if divides are delaying the retirement of instructions."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_DATA_RD.ANY_RESPONSE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_DATA_RD.ANY_RESPONSE", brief_description: "Counts any data read (demand & prefetch)  that have any response type", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 77969, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("UOPS_RETIRED.ALL", IntelPerformanceCounterDescription { event_code: Tuple::One(194), umask: Tuple::One(16), event_name: "UOPS_RETIRED.ALL", brief_description: "Micro-ops retired", public_description: Some("This event counts the number of micro-ops retired. The processor decodes complex macro instructions into a sequence of simpler micro-ops. Most instructions are composed of one or two micro-ops. Some instructions are decoded into longer sequences such as repeat instructions, floating point transcendental instructions, and assists. In some cases micro-op sequences are fused or whole instructions are fused into one micro-op. See other UOPS_RETIRED events for differentiating retired fused and non-fused micro-ops."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_RFO.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_RFO.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts demand and DCU prefetch RFOs  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179869186, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("REHABQ.ST_SPLITS", IntelPerformanceCounterDescription { event_code: Tuple::One(3), umask: Tuple::One(4), event_name: "REHABQ.ST_SPLITS", brief_description: "Store uops that split cache line boundary", public_description: Some("This event counts the number of retire stores that experienced cache line boundary splits"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_CODE_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_CODE_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts demand and DCU prefetch instruction cacheline  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179869188, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("CPU_CLK_UNHALTED.REF", IntelPerformanceCounterDescription { event_code: Tuple::One(60), umask: Tuple::One(1), event_name: "CPU_CLK_UNHALTED.REF", brief_description: "Reference cycles when core is not halted", public_description: Some("This event counts the number of reference cycles that the core is not in a halt state. The core enters the halt state when it is running the HLT instruction. In mobile systems the core frequency may change from time. This event is not affected by core frequency changes but counts as if the core is running at the maximum frequency all the time."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_MISP_RETIRED.NON_RETURN_IND", IntelPerformanceCounterDescription { event_code: Tuple::One(197), umask: Tuple::One(235), event_name: "BR_MISP_RETIRED.NON_RETURN_IND", brief_description: "Counts the number of mispredicted near indirect JMP and near indirect CALL branch instructions retired", public_description: Some("NON_RETURN_IND counts the number of mispredicted near indirect JMP and near indirect CALL branch instructions retired.  This event counts the number of retired branch instructions that were mispredicted by the processor, categorized by type. A branch misprediction occurs when the processor predicts that the branch would be taken, but it is not, or vice-versa.  When the misprediction is discovered, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_RFO.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_RFO.L2_MISS.ANY", brief_description: "Counts RFO requests generated by L2 prefetchers  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764192, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_DATA_RD.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_DATA_RD.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts data cacheline reads generated by L2 prefetchers  that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719476752, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_CODE_RD.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_CODE_RD.L2_MISS.ANY", brief_description: "Counts any code reads (demand & prefetch)  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764228, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_CODE_RD.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_CODE_RD.L2_MISS.SNOOP_MISS", brief_description: "Counts any code reads (demand & prefetch)  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589934660, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("RS_FULL_STALL.MEC", IntelPerformanceCounterDescription { event_code: Tuple::One(203), umask: Tuple::One(1), event_name: "RS_FULL_STALL.MEC", brief_description: "Counts the number of cycles and allocation pipeline is stalled and is waiting for a free MEC reservation station entry.  The cycles should be appropriately counted in case of the cracked ops e.g. In case of a cracked load-op, the load portion is sent to M", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_CODE_RD.ANY_RESPONSE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_CODE_RD.ANY_RESPONSE", brief_description: "Counts any code reads (demand & prefetch)  that have any response type", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 65604, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.IND_CALL", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(251), event_name: "BR_INST_RETIRED.IND_CALL", brief_description: "Counts the number of near indirect CALL branch instructions retired", public_description: Some("IND_CALL counts the number of near indirect CALL branch instructions retired.  Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_CODE_RD.ANY_RESPONSE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_CODE_RD.ANY_RESPONSE", brief_description: "Counts demand and DCU prefetch instruction cacheline  that have any response type", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 65540, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_RFO.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_RFO.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts RFO requests generated by L2 prefetchers  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179869216, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.JCC", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(126), event_name: "BR_INST_RETIRED.JCC", brief_description: "Counts the number of JCC branch instructions retired", public_description: Some("JCC counts the number of conditional branch (JCC) instructions retired. Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.STREAMING_STORES.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.STREAMING_STORES.L2_MISS.ANY", brief_description: "Counts streaming store  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636782592, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_RFO.ANY_RESPONSE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_RFO.ANY_RESPONSE", brief_description: "Counts any rfo reads (demand & prefetch)  that have any response type", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 65570, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("PAGE_WALKS.I_SIDE_CYCLES", IntelPerformanceCounterDescription { event_code: Tuple::One(5), umask: Tuple::One(2), event_name: "PAGE_WALKS.I_SIDE_CYCLES", brief_description: "Duration of I-side page-walks in core cycles", public_description: Some("This event counts every cycle when a I-side (walks due to an instruction fetch) page walk is in progress. Page walk duration divided by number of page walks is the average duration of page-walks."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("PAGE_WALKS.WALKS", IntelPerformanceCounterDescription { event_code: Tuple::One(5), umask: Tuple::One(3), event_name: "PAGE_WALKS.WALKS", brief_description: "Total page walks that are completed (I-side and D-side)", public_description: Some("This event counts when a data (D) page walk or an instruction (I) page walk is completed or started.  Since a page walk implies a TLB miss, the number of TLB misses can be counted by counting the number of pagewalks."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: true, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_RFO.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_RFO.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts any rfo reads (demand & prefetch)  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179869218, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("NO_ALLOC_CYCLES.NOT_DELIVERED", IntelPerformanceCounterDescription { event_code: Tuple::One(202), umask: Tuple::One(80), event_name: "NO_ALLOC_CYCLES.NOT_DELIVERED", brief_description: "Counts the number of cycles when no uops are allocated, the IQ is empty, and no other condition is blocking allocation.  The Silvermont implementation for this event is identical to NO_ALLOC_CYCLES.IQ_EMPTY.  This is a good approximation for NO_ALLOC_CYCLES.NOT_DELIVERED.", public_description: Some("The NO_ALLOC_CYCLES.NOT_DELIVERED event is used to measure front-end inefficiencies, i.e. when front-end of the machine is not delivering micro-ops to the back-end and the back-end is not stalled. This event can be used to identify if the machine is truly front-end bound.  When this event occurs, it is an indication that the front-end of the machine is operating at less than its theoretical peak performance.  Background: We can think of the processor pipeline as being divided into 2 broader parts: Front-end and Back-end. Front-end is responsible for fetching the instruction, decoding into micro-ops (uops) in machine understandable format and putting them into a micro-op queue to be consumed by back end. The back-end then takes these micro-ops, allocates the required resources.  When all resources are ready, micro-ops are executed. If the back-end is not ready to accept micro-ops from the front-end, then we do not want to count these as front-end bottlenecks.  However, whenever we have bottlenecks in the back-end, we will have allocation unit stalls and eventually forcing the front-end to wait until the back-end is ready to receive more UOPS. This event counts the cycles only when back-end is requesting more uops and front-end is not able to provide them. Some examples of conditions that cause front-end efficiencies are: Icache misses, ITLB misses, and decoder restrictions that limit the the front-end bandwidth."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("REHABQ.LOCK", IntelPerformanceCounterDescription { event_code: Tuple::One(3), umask: Tuple::One(16), event_name: "REHABQ.LOCK", brief_description: "Uops with lock semantics", public_description: Some("This event counts the number of retired memory operations with lock semantics. These are either implicit locked instructions such as the XCHG instruction or instructions with an explicit LOCK prefix (0xF0)."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("INST_RETIRED.ANY_P", IntelPerformanceCounterDescription { event_code: Tuple::One(192), umask: Tuple::One(0), event_name: "INST_RETIRED.ANY_P", brief_description: "Instructions retired", public_description: Some("This event counts the number of instructions that retire execution. For instructions that consist of multiple micro-ops, this event counts the retirement of the last micro-op of the instruction. The counter continues counting during hardware interrupts, traps, and inside interrupt handlers."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.CALL", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(249), event_name: "BR_INST_RETIRED.CALL", brief_description: "Counts the number of near CALL branch instructions retired", public_description: Some("CALL counts the number of near CALL branch instructions retired.  Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L1_DATA_RD.ANY_RESPONSE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L1_DATA_RD.ANY_RESPONSE", brief_description: "Counts DCU hardware prefetcher data read  that have any response type", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 73728, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("PAGE_WALKS.I_SIDE_WALKS", IntelPerformanceCounterDescription { event_code: Tuple::One(5), umask: Tuple::One(2), event_name: "PAGE_WALKS.I_SIDE_WALKS", brief_description: "I-side page-walks", public_description: Some("This event counts when an instruction (I) page walk is completed or started.  Since a page walk implies a TLB miss, the number of TLB misses can be counted by counting the number of pagewalks."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: true, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L1_DATA_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L1_DATA_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts DCU hardware prefetcher data read  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179877376, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_RFO.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_RFO.L2_MISS.SNOOP_MISS", brief_description: "Counts RFO requests generated by L2 prefetchers  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589934624, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("MEM_UOPS_RETIRED.ALL_LOADS", IntelPerformanceCounterDescription { event_code: Tuple::One(4), umask: Tuple::One(64), event_name: "MEM_UOPS_RETIRED.ALL_LOADS", brief_description: "All Loads", public_description: Some("This event counts the number of load ops retired"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_MISP_RETIRED.TAKEN_JCC", IntelPerformanceCounterDescription { event_code: Tuple::One(197), umask: Tuple::One(254), event_name: "BR_MISP_RETIRED.TAKEN_JCC", brief_description: "Counts the number of mispredicted taken JCC branch instructions retired", public_description: Some("TAKEN_JCC counts the number of mispredicted taken conditional branch (JCC) instructions retired.  This event counts the number of retired branch instructions that were mispredicted by the processor, categorized by type. A branch misprediction occurs when the processor predicts that the branch would be taken, but it is not, or vice-versa.  When the misprediction is discovered, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BACLEARS.RETURN", IntelPerformanceCounterDescription { event_code: Tuple::One(230), umask: Tuple::One(8), event_name: "BACLEARS.RETURN", brief_description: "Counts the number of RETURN baclears", public_description: Some("The BACLEARS event counts the number of times the front end is resteered, mainly when the Branch Prediction Unit cannot provide a correct prediction and this is corrected by the Branch Address Calculator at the front end.  The BACLEARS.RETURN event counts the number of RETURN baclears."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_DATA_RD.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_DATA_RD.L2_MISS.ANY", brief_description: "Counts demand and DCU prefetch data read  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764161, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_CODE_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_CODE_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts code reads generated by L2 prefetchers  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179869248, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_DATA_RD.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_DATA_RD.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts demand and DCU prefetch data read  that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719476737, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_CODE_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_CODE_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts any code reads (demand & prefetch)  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179869252, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("BR_MISP_RETIRED.JCC", IntelPerformanceCounterDescription { event_code: Tuple::One(197), umask: Tuple::One(126), event_name: "BR_MISP_RETIRED.JCC", brief_description: "Counts the number of mispredicted JCC branch instructions retired", public_description: Some("JCC counts the number of mispredicted conditional branches (JCC) instructions retired.  This event counts the number of retired branch instructions that were mispredicted by the processor, categorized by type. A branch misprediction occurs when the processor predicts that the branch would be taken, but it is not, or vice-versa.  When the misprediction is discovered, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_DATA_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_DATA_RD.L2_MISS.HIT_OTHER_CORE_NO_FWD", brief_description: "Counts data cacheline reads generated by L2 prefetchers  that miss L2 and the snoops to sibling cores hit in either E/S state and the line is not forwarded", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 17179869200, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_CODE_RD.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_CODE_RD.L2_MISS.ANY", brief_description: "Counts demand and DCU prefetch instruction cacheline  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764164, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("ICACHE.HIT", IntelPerformanceCounterDescription { event_code: Tuple::One(128), umask: Tuple::One(1), event_name: "ICACHE.HIT", brief_description: "Instruction fetches from Icache", public_description: Some("This event counts all instruction fetches from the instruction cache."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.REL_CALL", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(253), event_name: "BR_INST_RETIRED.REL_CALL", brief_description: "Counts the number of near relative CALL branch instructions retired", public_description: Some("REL_CALL counts the number of near relative CALL branch instructions retired.  Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("REHABQ.STA_FULL", IntelPerformanceCounterDescription { event_code: Tuple::One(3), umask: Tuple::One(32), event_name: "REHABQ.STA_FULL", brief_description: "Store address buffer full", public_description: Some("This event counts the number of retired stores that are delayed because there is not a store address buffer available."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("LONGEST_LAT_CACHE.REFERENCE", IntelPerformanceCounterDescription { event_code: Tuple::One(46), umask: Tuple::One(79), event_name: "LONGEST_LAT_CACHE.REFERENCE", brief_description: "L2 cache requests from this core", public_description: Some("This event counts requests originating from the core that references a cache line in the L2 cache"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_INST_RETIRED.RETURN", IntelPerformanceCounterDescription { event_code: Tuple::One(196), umask: Tuple::One(247), event_name: "BR_INST_RETIRED.RETURN", brief_description: "Counts the number of near RET branch instructions retired", public_description: Some("RETURN counts the number of near RET branch instructions retired.  Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. All branches utilize the branch prediction unit (BPU) for prediction. This unit predicts the target address not only based on the EIP of the branch but also based on the execution path through which execution reached this EIP. The BPU can efficiently predict the following branch types: conditional branches, direct calls and jumps, indirect calls and jumps, returns."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BR_MISP_RETIRED.ALL_BRANCHES", IntelPerformanceCounterDescription { event_code: Tuple::One(197), umask: Tuple::One(0), event_name: "BR_MISP_RETIRED.ALL_BRANCHES", brief_description: "Counts the number of mispredicted branch instructions retired", public_description: Some("ALL_BRANCHES counts the number of any mispredicted branch instructions retired. This umask is an architecturally defined event. This event counts the number of retired branch instructions that were mispredicted by the processor, categorized by type. A branch misprediction occurs when the processor predicts that the branch would be taken, but it is not, or vice-versa.  When the misprediction is discovered, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("L2_REJECT_XQ.ALL", IntelPerformanceCounterDescription { event_code: Tuple::One(48), umask: Tuple::One(0), event_name: "L2_REJECT_XQ.ALL", brief_description: "Counts the number of request from the L2 that were not accepted into the XQ", public_description: Some("This event counts the number of demand and prefetch transactions that the L2 XQ rejects due to a full or near full condition which likely indicates back pressure from the IDI link. The XQ may reject transactions from the L2Q (non-cacheable requests), BBS (L2 misses) and WOB (L2 write-back victims)"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_RFO.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_RFO.L2_MISS.ANY", brief_description: "Counts demand and DCU prefetch RFOs  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764162, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_CODE_RD.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_CODE_RD.L2_MISS.SNOOP_MISS", brief_description: "Counts code reads generated by L2 prefetchers  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589934656, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("BR_MISP_RETIRED.RETURN", IntelPerformanceCounterDescription { event_code: Tuple::One(197), umask: Tuple::One(247), event_name: "BR_MISP_RETIRED.RETURN", brief_description: "Counts the number of mispredicted near RET branch instructions retired", public_description: Some("RETURN counts the number of mispredicted near RET branch instructions retired.  This event counts the number of retired branch instructions that were mispredicted by the processor, categorized by type. A branch misprediction occurs when the processor predicts that the branch would be taken, but it is not, or vice-versa.  When the misprediction is discovered, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_DATA_RD.L2_MISS.SNOOP_MISS", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_DATA_RD.L2_MISS.SNOOP_MISS", brief_description: "Counts data cacheline reads generated by L2 prefetchers  that miss L2 with a snoop miss response", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 8589934608, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.PF_L2_CODE_RD.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.PF_L2_CODE_RD.L2_MISS.ANY", brief_description: "Counts code reads generated by L2 prefetchers  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636764224, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.COREWB.L2_MISS.NO_SNOOP_NEEDED", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.COREWB.L2_MISS.NO_SNOOP_NEEDED", brief_description: "Counts writeback (modified to exclusive)  that miss L2 with no details on snoop-related information", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 2147483656, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("MACHINE_CLEARS.MEMORY_ORDERING", IntelPerformanceCounterDescription { event_code: Tuple::One(195), umask: Tuple::One(2), event_name: "MACHINE_CLEARS.MEMORY_ORDERING", brief_description: "Stalls due to Memory ordering", public_description: Some("This event counts the number of times that pipeline was cleared due to memory ordering issues."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.ANY_DATA_RD.L2_MISS.ANY", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.ANY_DATA_RD.L2_MISS.ANY", brief_description: "Counts any data read (demand & prefetch)  that miss L2", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 96636776593, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
        ("MACHINE_CLEARS.SMC", IntelPerformanceCounterDescription { event_code: Tuple::One(195), umask: Tuple::One(1), event_name: "MACHINE_CLEARS.SMC", brief_description: "Self-Modifying Code detected", public_description: Some("This event counts the number of times that a program writes to a code section. Self-modifying code causes a severe penalty in all Intel? architecture processors."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("CPU_CLK_UNHALTED.CORE_P", IntelPerformanceCounterDescription { event_code: Tuple::One(60), umask: Tuple::One(0), event_name: "CPU_CLK_UNHALTED.CORE_P", brief_description: "Core cycles when core is not halted", public_description: Some("This event counts the number of core cycles while the core is not in a halt state. The core enters the halt state when it is running the HLT instruction. In mobile systems the core frequency may change from time to time. For this reason this event may have a changing ratio with regards to time."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("NO_ALLOC_CYCLES.MISPREDICTS", IntelPerformanceCounterDescription { event_code: Tuple::One(202), umask: Tuple::One(4), event_name: "NO_ALLOC_CYCLES.MISPREDICTS", brief_description: "Counts the number of cycles when no uops are allocated and the alloc pipe is stalled waiting for a mispredicted jump to retire.  After the misprediction is detected, the front end will start immediately but the allocate pipe stalls until the mispredicted", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("BACLEARS.ALL", IntelPerformanceCounterDescription { event_code: Tuple::One(230), umask: Tuple::One(1), event_name: "BACLEARS.ALL", brief_description: "Counts the number of baclears", public_description: Some("The BACLEARS event counts the number of times the front end is resteered, mainly when the Branch Prediction Unit cannot provide a correct prediction and this is corrected by the Branch Address Calculator at the front end.  The BACLEARS.ANY event counts the number of baclears for any type of branch."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("MEM_UOPS_RETIRED.ALL_STORES", IntelPerformanceCounterDescription { event_code: Tuple::One(4), umask: Tuple::One(128), event_name: "MEM_UOPS_RETIRED.ALL_STORES", brief_description: "All Stores", public_description: Some("This event counts the number of store ops retired"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("REHABQ.LD_BLOCK_STD_NOTREADY", IntelPerformanceCounterDescription { event_code: Tuple::One(3), umask: Tuple::One(2), event_name: "REHABQ.LD_BLOCK_STD_NOTREADY", brief_description: "Loads blocked due to store data not ready", public_description: Some("This event counts the cases where a forward was technically possible, but did not occur because the store data was not available at the right time"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("CPU_CLK_UNHALTED.CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(0), umask: Tuple::One(2), event_name: "CPU_CLK_UNHALTED.CORE", brief_description: "Fixed Counter: Counts the number of unhalted core clock cycles", public_description: Some("Counts the number of core cycles while the core is not in a halt state. The core enters the halt state when it is running the HLT instruction. This event is a component in many key event ratios.  The core frequency may change from time to time. For this reason this event may have a changing ratio with regards to time. In systems with a constant core frequency, this event can give you a measurement of the elapsed time while the core was not in halt state by dividing the event count by the core frequency. This event is architecturally defined and is a designated fixed counter.  CPU_CLK_UNHALTED.CORE and CPU_CLK_UNHALTED.CORE_P use the core frequency which may change from time to time.  CPU_CLK_UNHALTE.REF_TSC and CPU_CLK_UNHALTED.REF are not affected by core frequency changes but counts as if the core is running at the maximum frequency all the time.  The fixed events are CPU_CLK_UNHALTED.CORE and CPU_CLK_UNHALTED.REF_TSC and the programmable events are CPU_CLK_UNHALTED.CORE_P and CPU_CLK_UNHALTED.REF."), counter: Counter::Fixed(4), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 2000003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("MACHINE_CLEARS.FP_ASSIST", IntelPerformanceCounterDescription { event_code: Tuple::One(195), umask: Tuple::One(4), event_name: "MACHINE_CLEARS.FP_ASSIST", brief_description: "Stalls due to FP assists", public_description: Some("This event counts the number of times that pipeline stalled due to FP operations needing assists."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("ICACHE.ACCESSES", IntelPerformanceCounterDescription { event_code: Tuple::One(128), umask: Tuple::One(3), event_name: "ICACHE.ACCESSES", brief_description: "Instruction fetches", public_description: Some("This event counts all instruction fetches, including uncacheable fetches."), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("MEM_UOPS_RETIRED.L2_HIT_LOADS", IntelPerformanceCounterDescription { event_code: Tuple::One(4), umask: Tuple::One(2), event_name: "MEM_UOPS_RETIRED.L2_HIT_LOADS", brief_description: "Loads hit L2", public_description: Some("This event counts the number of load ops retired that hit in the L2"), counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 200003, msr_index: MSRIndex::None, msr_value: 0, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::PebsOrRegular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: false, unit: None, filter: None, extsel: false }),
        ("OFFCORE_RESPONSE.DEMAND_RFO.L2_MISS.HITM_OTHER_CORE", IntelPerformanceCounterDescription { event_code: Tuple::One(183), umask: Tuple::Two(1, 2), event_name: "OFFCORE_RESPONSE.DEMAND_RFO.L2_MISS.HITM_OTHER_CORE", brief_description: "Counts demand and DCU prefetch RFOs  that hit in the other module where modified copies were found in other core\'s L1 cache", public_description: None, counter: Counter::Programmable(3), counter_ht_off: Counter::Fixed(0), pebs_counters: Some(Counter::Programmable(1)), sample_after_value: 100007, msr_index: MSRIndex::Two(166, 167), msr_value: 68719476738, taken_alone: false, counter_mask: 0, invert: false, any_thread: false, edge_detect: false, pebs: PebsType::Regular, precise_store: false, data_la: false, l1_hit_indication: false, errata: None, offcore: true, unit: None, filter: None, extsel: false }),
    ]
}</code></pre></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../../../";
        window.currentCrate = "x86";
        window.playgroundUrl = "";
    </script>
    <script src="../../../../jquery.js"></script>
    <script src="../../../../main.js"></script>
    
    <script defer src="../../../../search-index.js"></script>
</body>
</html>